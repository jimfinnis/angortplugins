Notes for this, because it has to be done fairly carefully.

Defining options: done with a list of hashes.

Each opt hash:
    `description        :   prints in usage strings (required)
    `name               :   for long opts and results keys (like --help)
                            (required)
    `char               :   for short opts (like -x) (optional)
    `required           :   is option required? Boolean, (opt, default false)
    `type               :   `int, `float, `string, `bool, `list 
                            If list, the args are separated with `sepchar
                            and have the type `listtype. Non-boolean
                            implies that the option has an argument.
                            (Optional, default is `bool).
                            (opt, default `string)
    `sepchar            :   separator for lists (opt, default ",")
    `listtype           :   type of list items
    `default            :   the default value if `required is false
    
Other arguments: done with another list of hashes
Each argument:
    `description        :   prints in usage strings (required)
    `name               :   for results key (required)
    `required           :   is arg required? Boolean, (opt, default TRUE)
    `type               :   `int, `float, `string, `list 
                            If list, the args are separated with `sepchar
                            and have the type `listtype (required)
    `sepchar            :   separator for lists (opt, default ",")
    `listtype           :   type of list items
    `default            :   the default value if `required is false
Note: optional args must follow all the required args.    

Parsing:

    parse (optlist arglist-- results)
    
Results is a hash containing the value of each option and
argument keyed by name.



