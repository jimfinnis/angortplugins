#!/usr/local/bin/angort

package mpcc

[`sys,`mpc,`id3,`io] each { i library drop}

"HOME" sys$getenv !Home

:connect
    none 0 mpc$connect;

#number of songs to list in a listing

20 !ListWindow

private

# if a value is none, replace it with a string
:chknone |s:| ?s isnone
    if "<<NONE>>" else ?s then
;


# if a value is none, replace it with 0
:chknoneint |s:| ?s isnone
    if 0 else ?s then
;


# "decorate" a song hash, giving it a toString member.
:addstrconv |s/hash:|
    (   |x:|
        ?x?`artist chknone
        ": " +
        ?x?`title chknone +
    ) ?s!`toString;

# wrap a string with quotes
:quote |x:| "\"" ?x "\"" ++;

# maximum of a list
:maxlist
    0 swap (over over < if swap then drop) reduce
;

:dosearch |tag,str:|
    :"(tag str -- list) non exact search shortcut"
    [% ?tag ?str] 0 mpc$search
    # add the toString tag
    dup each{i addstrconv};

# show a list of songs in the playlist
:showlist |startidx,endidx:list,titlen,artlen,stat,i|
    mpc$list !list
    mpc$stat !stat
    "List length: " std$p ?list len.
    
    # get the bit of the list we want
    ?list ?startidx ?endidx ?startidx- 
    slice !list
    
    # work out some max lengths
    
    ?list (?`artist chknone len) map maxlist  !artlen
    ?list (?`title chknone len) map maxlist  !titlen
    
    # adjust them to fit the screen
    
    {
        ?titlen ?artlen + 70 > if 
            ?titlen 20 > if ?titlen 1- !titlen then
            ?artlen 20 > if ?artlen 1- !artlen then
        else
            leave
        then
    }
    
    ?startidx !i
    ?list each {
        ?i ?stat?`pos = if
            ">> " std$p
        else
            "   " std$p
        then
        
        [?i, 
         i?`artist chknone ?artlen trunc ?artlen padleft,
         i?`title  chknone ?titlen trunc ?titlen padleft] 
        "%4d %s %s" format .
        ?i 1+ !i
    }
;

# get the track number from the MPD track number string e.g. "11/14" gives 11. 
:gettrack |x:t|
    ?x?`track !x
    ?x isnone if
        0
    else
        ?x "/" stridx dup isnone if
            drop
            ?x toint
        else
            !t
            ?x 0 ?t slice toint
        then
    then
;

# sorting function to sort by album and then track number
:sortFunc |x,y:|
    ?x?`album chknone
    ?y?`album chknone
    cmp dup 0 = if
        drop
        ?x gettrack
        ?y gettrack cmp
    then
;

    
        
    



public

:timestr |s:m|
    ?s toint !s
    ?s 60 / !m
    ?s 60 % !s
    [?m,?s] "%02d:%02d" format
;
        
:getlist
    :"(-- list) get the current playlist"
    mpc$list dup each{i addstrconv};


:artist |name:|
    :"(name -- list) search for songs by an artist"
    `artist ?name dosearch;
    
:album |name:|
    :"(name -- list) search for songs on an album"
    `album ?name dosearch;

:song |name:|
    :"(name -- list) search for songs by title"
    `title ?name dosearch;

:grep |list,str:|
    :"(list str -- list) filter a list of songs for a string in the filename"
    ?list (?`name ?str istridx isnone not) filter;

:m
    :"(cmd --) run an mpc$mpc command and list the output"
    mpc$mpc each {i.};

global p # force a new definition in this namespace
:p
    :"(--) start playing"
    none mpc$play;
:s
    :"(--) stop playing"
    mpc$stop;

:ps
    :"(--) pause"
    mpc$pause;


    
global list # force a new definition in this namespace
:list |:stat,start,end|
    :"(n --) list the current playlist around the given song index"
    ?ListWindow 2/ -
    dup 0< if drop 0 then
    dup ?ListWindow +
    showlist;    


:l
    :"((n) --) list playlist. If stackct>1, show around that number, else show current"
    ct 0 = if
        mpc$stat ?`pos list
    else
        list
    then
;


:getn
    :"(n -- hash) get song N in the current list"
    getlist get;

:cur |:p|
    :"(-- hash) get current playing song"
    mpc$stat?`pos !p
    ?p 0 < not if
        ?p getlist get
    else
        none
    then
;

:stat |:stat,list|
    :"(--) show current status"
    mpc$stat !stat
    mpc$list !list # don't need to decorate with a toString member
    
    "State : " ?stat?`state +
    "  Volume : " ?stat?`volume + +.
    ?stat?`pos 0 < not if
        ?stat?`pos ?list get
        "Current Song: " std$p dup ?`title.
        "by            " std$p dup ?`artist.
        "from          " std$p ?`album.
        "at            " std$p 
        ?stat?`elapsed timestr "/" ?stat?`total timestr + + .
    then
;

:v mpc$setvol;

:clr :"(--) clear the playlist"
    mpc$clr;
:add :"(list --) add a list of songs to the  playlist"
    mpc$add;

:dmp |x:|
    :"(lst --) dump a list or hash"
    ?x type `hash = if
        ?x each {i std$p "   " std$p i ?x get .}
    else
        ?x each {i.}
    then;
    
:d 
    :"(n --) delete item in current playlist"
    mpc$del;

:f 
    :"(--) move forwards in current playlist"
    mpc$next;

:b 
    :"(--) move backwards in current playlist"
    mpc$prev;

:g |x:|
    :"(n --) start playing from given song index in playlist"
    ?x mpc$play;

:shuf |lst:n,a,l|
    :"(list -- list) shuffle a list"
    ?lst len !l
    ?l 1- 0 range each {
        rand i % !a
        i ?lst get
        ?a ?lst get
        i ?lst set
        ?a ?lst set
    } ?lst;


:rm
    :"(name --) delete a playlist"
    mpc$rm;

:ls
    :"(--) list all stored playlists"
    mpc$playlists each {i.};

:allsongs |:ids|
    :"(--list) list all songs (takes ages)"
    []
    `artist [%] mpc$tags each {i.
        [% `artist i] 1 mpc$search each{i dup addstrconv, }
    }
;

    
:h
    :"(--) list all music player public words"
    "mpcc" listhelp
;

:getfn 
    :"(hash -- file) get full name (only works on local machine)"
    ?Home "/beetsmusic/" +
    swap ?`name +
;

:loadtags
    :"(hash -- hash) read song tags into a hash"
    getfn id3$loadtags
;

:spp 20 padright;
:gfs |x,s:| # get from song
    ?s ?x?`songhash get chknone
;


:showprobs |:t|
    :"Scan for common errors in all ID3 tags - takes quite a while"
    
    allsongs !t
    nl nl nl
    
    # first check, scan the files for weird null data
    ?t each {
        i?`artist isnone if "Null artist: " spp i?`name . then
        i?`title isnone if "Null title: " spp  i?`name . then
    }
    
    # below here won't work unless the data is local. It stores
    # the tag data in the song hash.
    [] ?t each {i loadtags i over !`songhash ,}
    
    each {
        i?`artist isnone if "Null artist: " spp i `name gfs +. then
        i?`title isnone if "Null title: " spp  i `name gfs +. then
    }
;

:savefile |n:f|
    :"(n --) save queue to local file (preserves play position)"
    ?n "w" io$open !f
    mpc$stat ?`pos ?f io$write
    mpc$list ?f io$write
;

:addfile |n:f,p,l|
    :"(n --) append list from local file to queue"
    ?n "r" io$open !f
    ?f isnone if "Cannot open file "p ?n. stop then
    ?f io$read32 !p
    "Playlist position: " std$p ?p .
    ?f io$readlist !l
    "Adding " std$p ?l len std$p " items.".
    ?l mpc$add
    # don't seek, play number will be wrong
;
    
:loadfile |n:f|
    :"(n --) load queue from local file (preserves play position)"
    clr
    ?n "r" io$open !f
    ?f isnone if "Cannot open file " std$p ?n. stop then
    ?f io$read32 !p
    ?p 0 < if 0!p then
        
    "Playlist position: " std$p ?p .
    ?f io$readlist !l
    "Adding " std$p ?l len std$p " items.".
    ?l mpc$add
    ?p 0 mpc$seek
;

:save
    :"(--) shortcut to save playlist and pos"
    ?Home "/.angortmplist" + savefile
    
;

:load
    :"(--) shortcut to save playlist and pos"
    ?Home "/.angortmplist" + loadfile
;
    
    


:srt
    :"(list -- list) sort list by album, then track"
    clone dup (sortFunc) fsort
;

:lsrt
    :"(--) sort playlist by album, then track"
    mpc$list dup (sortFunc) fsort clr add
;

# add words here for your standard connections
:pi "pi" 0 mpc$connect;
:cran "cranberry" 0 mpc$connect;

endpackage import

# add your default connect here
pi
