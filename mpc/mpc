#!/usr/local/bin/angort

package mpcc

[`curl,`time,`regex, `sys,`mpc,`id3,`io] each { i library drop}

"HOME" getenv !Home

:connect
    none 0 mpc$connect;

#number of songs to list in a listing

20 !ListWindow

private

:showbool |b/integer,s/string:|
    ?s std$p " " std$p ?b if "ON " else "OFF" then std$p
;


# if a value is none, replace it with a string
:chknone |s:| ?s isnone
    if "<<NONE>>" else ?s then
;

# if a value is none, replace it with 0
:chknoneint |s:| ?s isnone
    if 0 else ?s then
;


# "decorate" a song hash, giving it a toString member.
:addstrconv |s/hash:|
    (   |x:|
        ?x?`artist chknone
        ": " +
        ?x?`title chknone +
    ) ?s!`toString;

# wrap a string with quotes
:quote |x:| "\"" ?x "\"" ++;

# maximum of a list
:maxlist
    0 swap (over over < if swap then drop) reduce
;

:dosearch |tag,str:|
    :"(tag str -- list) non exact search shortcut"
    [% ?tag ?str] 0 mpc$search
    # add the toString tag
    dup each{i addstrconv};

# show a list of songs in the playlist
:showlist |startidx,endidx:list,titlen,artlen,stat,i|
    mpc$list !list
    mpc$stat !stat
    "List length: " std$p ?list len.
    
    # get the bit of the list we want
    ?list ?startidx ?endidx ?startidx- 
    slice !list
    
    # work out some max lengths
    
    ?list (?`artist chknone len) map maxlist  !artlen
    ?list (?`title chknone len) map maxlist  !titlen
    
    # adjust them to fit the screen
    
    {
        ?titlen ?artlen + 70 > if 
            ?titlen 20 > if ?titlen 1- !titlen then
            ?artlen 20 > if ?artlen 1- !artlen then
        else
            leave
        then
    }
    
    ?startidx !i
    ?list each {
        ?i ?stat?`pos = if
            ">> " std$p
        else
            "   " std$p
        then
        
        [?i, 
         i?`artist chknone ?artlen trunc ?artlen padleft,
         i?`title  chknone ?titlen trunc ?titlen padleft] 
        "%4d %s %s" format .
        ?i 1+ !i
    }
;

# get the track number from the MPD track number string e.g. "11/14" gives 11. 
:gettrack |x:t|
    ?x?`track !x
    ?x isnone if
        0
    else
        ?x "/" stridx dup isnone if
            drop
            ?x toint
        else
            !t
            ?x 0 ?t slice toint
        then
    then
;

# sorting function to sort by album and then track number
:sortFunc |x,y:|
    ?x?`album chknone
    ?y?`album chknone
    cmp dup 0 = if
        drop
        ?x gettrack
        ?y gettrack cmp
    then
;

    
        
    



public

:rep |:t|
    mpc$stat?`repeat not dup
    mpc$setrepeat
    "Repeat is now" showbool nl
;
:rnd |:t|
    mpc$stat?`random not dup
    mpc$setrandom
    "Random is now" showbool nl
;

:timestr |s:m|
    ?s toint !s
    ?s 60 / !m
    ?s 60 % !s
    [?m,?s] "%02d:%02d" format
;
        
:getlist
    :"(-- list) get the current playlist"
    mpc$list dup each{i addstrconv};


:artist |name:|
    :"(name -- list) search for songs by an artist"
    `artist ?name dosearch;
    
:album |name:|
    :"(name -- list) search for songs on an album"
    `album ?name dosearch;

:song |name:|
    :"(name -- list) search for songs by title"
    `title ?name dosearch;

:grep |list,str:|
    :"(list str -- list) filter a list of songs for a string in the filename"
    ?list (?`name ?str istridx isnone not) filter;

:m
    :"(cmd --) run an mpc$mpc command and list the output"
    mpc$mpc each {i.};

global p # force a new definition in this namespace
:p
    :"(--) start playing"
    none mpc$play;
:s
    :"(--) stop playing"
    mpc$stop;

:ps
    :"(--) pause"
    mpc$pause;


    
global list # force a new definition in this namespace
:list |:stat,start,end|
    :"(n --) list the current playlist around the given song index"
    ?ListWindow 2/ -
    dup 0< if drop 0 then
    dup ?ListWindow +
    showlist;    


:l
    :"((n) --) list playlist. If stackct>1, show around that number, else show current"
    ct 0 = if
        mpc$stat ?`pos list
    else
        list
    then
;


:getn
    :"(n -- hash) get song N in the current list"
    getlist get;

:cur |:p|
    :"(-- hash) get current playing song"
    mpc$stat?`pos !p
    ?p 0 < not if
        ?p getlist get
    else
        none
    then
;

:stat |:stat,list|
    :"(--) show current status"
    mpc$stat !stat
    mpc$list !list # don't need to decorate with a toString member
    
    "State : " ?stat?`state +
    "  Volume : " ?stat?`volume + +.
    ?stat?`pos 0 < not if
        ?stat?`pos ?list get
        "Current Song: " std$p dup ?`title.
        "by            " std$p dup ?`artist.
        "from          " std$p ?`album.
        "at            " std$p 
        ?stat?`elapsed timestr "/" ?stat?`total timestr + + .
    then
    ?stat?`repeat "Repeat" showbool "    " std$p
    ?stat?`random "Random" showbool nl
    ?stat?`update if "UPDATING". then
;

:statstr |s,sym,c:|
    ?sym ?s get if ?c else "." then;

:longprompt |g,s,c:t,list,song|
    try
        mpc$stat !stat
        #stat chars
        ?stat `repeat "r" statstr
        ?stat `random "R" statstr +
        ?stat `update "u" statstr +
        ?stat?`state <<[%
           `play ">",
           `stop "s",
           `pause "p"
           ]>> get !t
        ?t isnone if "?" else ?t then + 
        " " +
        # list position
        mpc$list !list
        ?stat?`pos + "/" + ?list len + " " +
        ?stat?`state `play = ?stat?`state `pause = or if
            ?stat?`pos ?list get !song
            ?song?`title chknone 20 trunc + "/" +
            ?song?`album chknone 20 trunc + "/" +
            ?song?`artist chknone 20 trunc + 
        then
        "|   "+

    catch: ex$failed,ex$notready
        "ERR"
    endtry
    
    " " + ?g + "|" + ?s + " " + ?c + " " +
;

?longprompt cli$prompt

:v mpc$setvol;

:clr :"(--) clear the playlist"
    mpc$clr;
:add :"(list --) add a list of songs to the  playlist"
    mpc$add;

:dmp |x:|
    :"(lst --) dump a list or hash"
    ?x type `hash = if
        ?x each {i std$p "   " std$p i ?x get .}
    else
        ?x each {i.}
    then;
    
:d 
    :"(n --) delete item in current playlist"
    mpc$del;

:f 
    :"(--) move forwards in current playlist"
    mpc$next;

:b 
    :"(--) move backwards in current playlist"
    mpc$prev;

:g |x:|
    :"(n --) start playing from given song index in playlist"
    ?x mpc$play;

:shuf |lst:n,a,l|
    :"(list -- list) shuffle a list"
    ?lst len !l
    ?l 1- 0 range each {
        rand i % !a
        i ?lst get
        ?a ?lst get
        i ?lst set
        ?a ?lst set
    } ?lst;


:rm
    :"(name --) delete a playlist"
    mpc$rm;

:ls
    :"(--) list all stored playlists"
    mpc$playlists each {i.};

:allsongs |:ids|
    :"(--list) list all songs (takes ages)"
    []
    `artist [%] mpc$tags each {i.
        [% `artist i] 1 mpc$search each{i dup addstrconv, }
    }
;

    
:h
    :"(--) list all music player public words"
    "mpcc" listhelp
;

:getfn 
    :"(hash -- file) get full name (only works on local machine)"
    ?Home "/beetsmusic/" +
    swap ?`name +
;

:loadtags
    :"(hash -- hash) read song tags into a hash"
    getfn id3$loadtags
;

:spp 20 padright;
:gfs |x,s:| # get from song
    ?s ?x?`songhash get chknone
;


:showprobs |:t|
    :"Scan for common errors in all ID3 tags - takes quite a while"
    
    allsongs !t
    nl nl nl
    
    # first check, scan the files for weird null data
    ?t each {
        i?`artist isnone if "Null artist: " spp i?`name . then
        i?`title isnone if "Null title: " spp  i?`name . then
    }
    
    # below here won't work unless the data is local. It stores
    # the tag data in the song hash.
    [] ?t each {i loadtags i over !`songhash ,}
    
    each {
        i?`artist isnone if "Null artist: " spp i `name gfs +. then
        i?`title isnone if "Null title: " spp  i `name gfs +. then
    }
;

:savefile |n:f|
    :"(n --) save queue to local file (preserves play position)"
    ?n "w" io$open !f
    mpc$stat ?`pos ?f io$write
    mpc$list ?f io$write
;

:addfile |n:f,p,l|
    :"(n --) append list from local file to queue"
    ?n "r" io$open !f
    ?f isnone if "Cannot open file "p ?n. stop then
    ?f io$read32 !p
    "Playlist position: " std$p ?p .
    ?f io$readlist !l
    "Adding " std$p ?l len std$p " items.".
    ?l mpc$add
    # don't seek, play number will be wrong
;
    
:loadfile |n:f|
    :"(n --) load queue from local file (preserves play position)"
    clr
    ?n "r" io$open !f
    ?f isnone if "Cannot open file " std$p ?n. stop then
    ?f io$read32 !p
    ?p 0 < if 0!p then
        
    "Playlist position: " std$p ?p .
    ?f io$readlist !l
    "Adding " std$p ?l len std$p " items.".
    ?l mpc$add
    ?p 0 mpc$seek
;

:sv
    :"(--) shortcut to save playlist and pos"
    ?Home "/.angortmplist" + savefile
    
;

:ld
    :"(--) shortcut to save playlist and pos"
    ?Home "/.angortmplist" + loadfile
;
    
    


:srt
    :"(list -- list) sort list by album, then track"
    clone dup (sortFunc) fsort
;

:lsrt
    :"(--) sort playlist by album, then track"
    mpc$list dup (sortFunc) fsort clr add
;

# add words here for your standard connections
:pi "pi" 0 mpc$connect;
:cran "cranberry" 0 mpc$connect;



# experimental stuff for mp3/shoutcast

:addmp3 |n:|
    [%
     `name ?n,
     `album "Radio",
     `title ?n
     ]
    mpc$add
;

# this works OK for radio 3!
:addshoutcast |n:rxFile,rxTitle,filelist,titlelist,t,curl|
    "File.*" regex$compile !rxFile
    "Title.*" regex$compile !rxTitle
    [] !filelist
    [] !titlelist
    
    # first, grab the curl file
    try
        curl$make !curl
        ?curl
        [%
         `url ?n
         ]
        curl$setopt curl$perform
        isnone not if "cannot open URL" `scerror throw then
        
        ?curl curl$data "\n" split 
        each {
            cases
                i ?rxFile regex$match len if
                    i "=" split !t
                    ?t shift 4 -1 substr toint !n
                    ?t "=" intercalate ?n ?filelist set
                case
                i ?rxTitle regex$match len if
                    i "=" split !t
                    ?t shift 5 -1 substr toint !n
                    ?t "=" intercalate ?n ?titlelist set
                case
            otherwise
        }
            
        ?filelist ?titlelist (|a,b:| 
            [%
             `name ?a,
             `title ?b]
        ) zipWith
        (?`name isnone not)filter
         
        each{
            "adding " std$p i?`name .
            i add}
    catch :scerror
        "Error : " std$p
        drop .
    endtry
;

# special radio stations!

:radio3
    clr 
    "http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/http-icy-aac-lc-a/format/pls/vpid/bbc_radio_three.pls"
    addshoutcast p
;

:divline
    clr
    "http://thedividingline.com:8000/dlbn.mp3"
    addmp3 p
;

:progzilla
    clr "http://stream1.hippynet.co.uk:8005/live"
    addmp3 p
;

# live streaming from darkice->icecast2 on terence.
# See StreamingAudioToPi on terence, but the basics are
# to run darkice -c darkice.cfg in that directory before
# running this.
:terence
    clr "http://192.168.2.10:8000/terence"
    addmp3 p
;

endpackage import

# add your default connect here
pi
